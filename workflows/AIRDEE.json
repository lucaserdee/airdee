{
  "name": "AIRDEE",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ai-chatbot",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "60cb302c-898b-47e1-9080-abd0bd91e62d",
      "name": "Chat UI webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "webhookId": "0e361650-fbdc-493a-82ea-1081b0fc552b"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * Validate Request — Europe/Amsterdam tijdsparser met UTC-output\n * In:  body.question (string), optioneel: body.timeRange | body.daterange | body.range\n *      Optioneel: body.fromISO / body.toISO (overrides), body.forceNewest (bool)\n * Out: question, fromISO, toISO, _timeRangeParsed (label), forceNewest, sourcePref, authorHint\n *\n * Extra gedrag:\n * - Detecteert auteur in NL-vragen (“door/van/auteur <Naam>”) → sourcePref='td'\n * - “meest recente / laatste / recentste” zet forceNewest=true (behoudt meegegeven body.forceNewest)\n * - Robuuste NL-tijdsfrasen (“afgelopen week”, “deze maand”, “tussen A en B”, datumformaten, …)\n * - Tijdvenster: [fromISO, toISO) in UTC. Corrigeert from>=to.\n */\n\nconst TZ = 'Europe/Amsterdam';\n\n// --------------------- Helpers: TZ en daggrenzen ---------------------\nconst toIsoUtc = (d) => new Date(d.getTime()).toISOString();\n\nfunction startOfDayInTzUTC(d = new Date(), tz = TZ) {\n  const local = new Date(d.toLocaleString('en-US', { timeZone: tz }));\n  local.setHours(0, 0, 0, 0);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\nfunction addDaysInTzUTC(dayStartUTC, n, tz = TZ) {\n  const local = new Date(dayStartUTC.toLocaleString('en-US', { timeZone: tz }));\n  local.setDate(local.getDate() + n);\n  local.setHours(0, 0, 0, 0);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\nfunction startOfWeekInTzUTC(d = new Date(), tz = TZ) {\n  const local = new Date(d.toLocaleString('en-US', { timeZone: tz }));\n  local.setHours(0, 0, 0, 0);\n  const weekday = local.getDay(); // 0=zo..6=za\n  const offset = (weekday + 6) % 7; // ma=0\n  local.setDate(local.getDate() - offset);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\nfunction startOfMonthInTzUTC(d = new Date(), tz = TZ) {\n  const local = new Date(d.toLocaleString('en-US', { timeZone: tz }));\n  local.setFullYear(local.getFullYear(), local.getMonth(), 1);\n  local.setHours(0, 0, 0, 0);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\nfunction startOfYearInTzUTC(d = new Date(), tz = TZ) {\n  const local = new Date(d.toLocaleString('en-US', { timeZone: tz }));\n  local.setFullYear(local.getFullYear(), 0, 1);\n  local.setHours(0, 0, 0, 0);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\n// --------------------- Datum parsing (NL) ---------------------\nconst MONTHS = {\n  januari: 0, februari: 1, maart: 2, april: 3, mei: 4, juni: 5,\n  juli: 6, augustus: 7, september: 8, oktober: 9, november: 10, december: 11,\n};\n\n/**\n * Parse \"dd-mm(-yyyy)\" | \"dd/mm(/yyyy)\" | \"dd <maand> (yyyy)\" | ISO\n * → UTC instant van lokale dagstart in TZ (of null)\n */\nfunction parseLooseDateToTzStartUTC(s, defaultYear, tz = TZ) {\n  if (!s) return null;\n  s = String(s).trim().toLowerCase();\n\n  // dd-mm(-yyyy) | dd/mm(/yyyy) | dd.mm(.yyyy)\n  let m = s.match(/^(\\d{1,2})[.\\-\\/ ](\\d{1,2})(?:[.\\-\\/ ](\\d{2,4}))?$/);\n  if (m) {\n    const d = +m[1], mo = +m[2], y = m[3] ? +m[3] : defaultYear;\n    const yyyy = y < 100 ? 2000 + y : y;\n    const local = new Date(new Date().toLocaleString('en-US', { timeZone: tz }));\n    local.setFullYear(yyyy, mo - 1, d);\n    local.setHours(0, 0, 0, 0);\n    return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n  }\n\n  // dd <maand> (yyyy)\n  m = s.match(/^(\\d{1,2})[ ]([a-z]+)\\.?(?:[ ](\\d{2,4}))?$/i);\n  if (m) {\n    const d = +m[1];\n    const monName = m[2].replace(/\\.$/, '');\n    const mo = MONTHS[monName];\n    if (mo !== undefined) {\n      const y = m[3] ? +m[3] : defaultYear;\n      const yyyy = y < 100 ? 2000 + y : y;\n      const local = new Date(new Date().toLocaleString('en-US', { timeZone: tz }));\n      local.setFullYear(yyyy, mo, d);\n      local.setHours(0, 0, 0, 0);\n      return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n    }\n  }\n\n  // ISO fallback → neem kalenderdag in TZ\n  const iso = new Date(s);\n  if (!isNaN(iso.getTime())) {\n    const local = new Date(iso.toLocaleString('en-US', { timeZone: tz }));\n    local.setHours(0, 0, 0, 0);\n    return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n  }\n\n  return null;\n}\n\n// --------------------- Tijdsrange parser (NL) ---------------------\nfunction parseTimeRangeNL(input, questionText) {\n  const src = (input || questionText || '').trim();\n  if (!src) return { fromISO: null, toISO: null, label: null };\n\n  const s = src.toLowerCase();\n  const now = new Date();\n  const todayUTC = startOfDayInTzUTC(now);\n  const tomorrowUTC = addDaysInTzUTC(todayUTC, 1);\n\n  // vandaag / gisteren / eergisteren\n  if (/\\bvandaag\\b/.test(s)) {\n    return { fromISO: toIsoUtc(todayUTC), toISO: toIsoUtc(tomorrowUTC), label: 'vandaag' };\n  }\n  if (/\\bgisteren\\b/.test(s)) {\n    const yUTC = addDaysInTzUTC(todayUTC, -1);\n    return { fromISO: toIsoUtc(yUTC), toISO: toIsoUtc(todayUTC), label: 'gisteren' };\n  }\n  if (/\\beergisteren\\b/.test(s)) {\n    const d2UTC = addDaysInTzUTC(todayUTC, -2);\n    const d1UTC = addDaysInTzUTC(todayUTC, -1);\n    return { fromISO: toIsoUtc(d2UTC), toISO: toIsoUtc(d1UTC), label: 'eergisteren' };\n  }\n\n  // “afgelopen twee weken”\n  if (/(afgelopen|laatste)\\s*(twee|2)\\s*weken?\\b/.test(s)) {\n    const from = addDaysInTzUTC(todayUTC, -14);\n    return { fromISO: toIsoUtc(from), toISO: toIsoUtc(tomorrowUTC), label: 'afgelopen twee weken' };\n  }\n\n  // “afgelopen N dagen/weken/maanden/jaar”\n  let m = s.match(/(afgelopen|laatste)\\s*(\\d{1,3})\\s*(dagen?|weken?|maanden?|jaar)\\b/);\n  if (m) {\n    const n = +m[2];\n    const unit = m[3];\n    let fromUTC = todayUTC;\n\n    if (/dag/.test(unit)) {\n      fromUTC = addDaysInTzUTC(todayUTC, -n);\n    } else if (/week/.test(unit)) {\n      fromUTC = addDaysInTzUTC(todayUTC, -7 * n);\n    } else if (/maand/.test(unit)) {\n      const localNow = new Date(now.toLocaleString('en-US', { timeZone: TZ }));\n      localNow.setMonth(localNow.getMonth() - n, 1);\n      localNow.setHours(0, 0, 0, 0);\n      fromUTC = new Date(localNow.toLocaleString('en-US', { timeZone: 'UTC' }));\n    } else if (/jaar/.test(unit)) {\n      const localNow = new Date(now.toLocaleString('en-US', { timeZone: TZ }));\n      localNow.setFullYear(localNow.getFullYear() - n, 0, 1);\n      localNow.setHours(0, 0, 0, 0);\n      fromUTC = new Date(localNow.toLocaleString('en-US', { timeZone: 'UTC' }));\n    }\n\n    return { fromISO: toIsoUtc(fromUTC), toISO: toIsoUtc(tomorrowUTC), label: `afgelopen ${n} ${unit}` };\n  }\n\n  // “vorige week”\n  if (/\\b(vorige|afgelopen)\\s+week\\b/.test(s)) {\n    const startThisWeekUTC = startOfWeekInTzUTC(now);\n    const startPrevWeekUTC = addDaysInTzUTC(startThisWeekUTC, -7);\n    return { fromISO: toIsoUtc(startPrevWeekUTC), toISO: toIsoUtc(startThisWeekUTC), label: 'vorige week' };\n  }\n\n  // “deze week”\n  if (/\\bdeze\\s+week\\b/.test(s)) {\n    const startThisWeekUTC = startOfWeekInTzUTC(now);\n    return { fromISO: toIsoUtc(startThisWeekUTC), toISO: toIsoUtc(tomorrowUTC), label: 'deze week' };\n  }\n\n  // “vorige maand”\n  if (/\\b(vorige|afgelopen)\\s+maand\\b/.test(s)) {\n    const firstThisUTC = startOfMonthInTzUTC(now);\n    const localThis = new Date(firstThisUTC.toLocaleString('en-US', { timeZone: TZ }));\n    localThis.setMonth(localThis.getMonth() - 1, 1);\n    localThis.setHours(0, 0, 0, 0);\n    const firstPrevUTC = new Date(localThis.toLocaleString('en-US', { timeZone: 'UTC' }));\n    return { fromISO: toIsoUtc(firstPrevUTC), toISO: toIsoUtc(firstThisUTC), label: 'vorige maand' };\n  }\n\n  // “deze maand”\n  if (/\\bdeze\\s+maand\\b/.test(s)) {\n    const firstThisUTC = startOfMonthInTzUTC(now);\n    return { fromISO: toIsoUtc(firstThisUTC), toISO: toIsoUtc(addDaysInTzUTC(startOfDayInTzUTC(now), 1)), label: 'deze maand' };\n  }\n\n  // “vorig jaar”\n  if (/\\b(vorig|afgelopen)\\s+jaar\\b/.test(s)) {\n    const firstThisYearUTC = startOfYearInTzUTC(now);\n    const localThis = new Date(firstThisYearUTC.toLocaleString('en-US', { timeZone: TZ }));\n    localThis.setFullYear(localThis.getFullYear() - 1, 0, 1);\n    localThis.setHours(0, 0, 0, 0);\n    const firstPrevYearUTC = new Date(localThis.toLocaleString('en-US', { timeZone: 'UTC' }));\n    return { fromISO: toIsoUtc(firstPrevYearUTC), toISO: toIsoUtc(firstThisYearUTC), label: 'vorig jaar' };\n  }\n\n  // “dit jaar”\n  if (/\\bdit\\s+jaar\\b/.test(s)) {\n    const firstThisYearUTC = startOfYearInTzUTC(now);\n    return { fromISO: toIsoUtc(firstThisYearUTC), toISO: toIsoUtc(addDaysInTzUTC(startOfDayInTzUTC(now), 1)), label: 'dit jaar' };\n  }\n\n  // “A t/m B” (inclusief B → tot B+1 dag 00:00)\n  let m2 = s.match(/(.+?)\\s*t\\/m\\s*(.+)$/i);\n  if (m2) {\n    const a = parseLooseDateToTzStartUTC(m2[1], now.getFullYear(), TZ);\n    const b = parseLooseDateToTzStartUTC(m2[2], now.getFullYear(), TZ);\n    if (a && b) return { fromISO: toIsoUtc(a), toISO: toIsoUtc(addDaysInTzUTC(b, 1)), label: 'custom range' };\n  }\n\n  // “tussen A en B” (inclusief B → tot B+1)\n  m2 = s.match(/tussen\\s+(.+?)\\s+en\\s+(.+)$/i);\n  if (m2) {\n    const a = parseLooseDateToTzStartUTC(m2[1], now.getFullYear(), TZ);\n    const b = parseLooseDateToTzStartUTC(m2[2], now.getFullYear(), TZ);\n    if (a && b) return { fromISO: toIsoUtc(a), toISO: toIsoUtc(addDaysInTzUTC(b, 1)), label: 'custom range' };\n  }\n\n  // “op <datum>”\n  m2 = s.match(/\\bop\\s+(.+)$/i);\n  if (m2) {\n    const d0 = parseLooseDateToTzStartUTC(m2[1], now.getFullYear(), TZ);\n    if (d0) return { fromISO: toIsoUtc(d0), toISO: toIsoUtc(addDaysInTzUTC(d0, 1)), label: 'op dag' };\n  }\n\n  return { fromISO: null, toISO: null, label: null };\n}\n\n// --------------------- Auteur & bronkeuze ---------------------\nfunction detectAuthor(q = '') {\n  const s = String(q).trim();\n  const m =\n    s.match(/\\b(?:door|van|auteur)\\s+([A-ZÁÉÍÓÚÄËÏÖÜÀÈÌÒÙ][\\w.'-]+(?:\\s+[A-Z][\\w.'-]+){0,3})\\b/) ||\n    s.match(/\\b([A-ZÁÉÍÓÚÄËÏÖÜÀÈÌÒÙ][\\w.'-]+(?:\\s+[A-Z][\\w.'-]+){0,3})\\s+(?:schreef|publiceerde)\\b/i);\n  return m ? m[1].trim() : null;\n}\n\nfunction wantsNewest(q = '') {\n  return /\\b(meest\\s+recent|recentste|laatste)\\b/i.test(q);\n}\n\nfunction detectSourcePref(q) {\n  const s = (q || '').toLowerCase();\n  const wantsRD = /\\b(rd|reformatorisch\\s+dagblad|reformatorischdagblad|rd\\.nl)\\b/.test(s);\n  const wantsTD = /\\b(td|terdege|terdege\\s+magazine|terdege\\.nl)\\b/.test(s);\n  if (wantsRD && !wantsTD) return 'rd';\n  if (wantsTD && !wantsRD) return 'td';\n  const softRD = /\\b(dagblad|krant)\\b/.test(s);\n  const softTD = /\\b(magazine|terdege-?)\\b/.test(s);\n  if (softRD && !softTD) return 'rd';\n  if (softTD && !softRD) return 'td';\n  return 'both';\n}\n\n// --------------------- Node-uitvoering ---------------------\nconst body = $json.body ?? {};\nconst question = String(body.question ?? '').trim();\nif (!question) throw new Error('question ontbreekt in de request payload.');\n\n// 1) Tijdvenster bepalen\nconst explicitTR = body.timeRange ?? body.daterange ?? body.range ?? null;\nlet { fromISO, toISO, label } = parseTimeRangeNL(explicitTR, question);\n\n// Overrides: body.fromISO / body.toISO (indien meegegeven)\nif (body.fromISO) fromISO = new Date(body.fromISO).toISOString();\nif (body.toISO)   toISO   = new Date(body.toISO).toISOString();\n\n// Corrigeer from>=to → maak minimaal 1 dag venster\nif (fromISO && toISO && new Date(fromISO) >= new Date(toISO)) {\n  const fixTo = addDaysInTzUTC(new Date(fromISO), 1);\n  toISO = toIsoUtc(fixTo);\n}\n\n// 2) “nieuwste/laatste/recentste”\nlet forceNewest = !!body.forceNewest || wantsNewest(question);\n\n// 3) Auteur & bronkeuze\nconst authorHint = detectAuthor(question);\nlet sourcePref = detectSourcePref(question);\n\n// Als er een auteursnaam wordt genoemd → altijd TD gebruiken\nif (authorHint) sourcePref = 'td';\n\nreturn {\n  question,\n  fromISO,\n  toISO,\n  _timeRangeParsed: label,\n  forceNewest,\n  sourcePref,\n  authorHint,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ],
      "id": "12355c8e-7433-4c0c-a3ab-5d7c97e3caa8",
      "name": "Validate Request"
    },
    {
      "parameters": {
        "model": "gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAzureOpenAi",
      "typeVersion": 1,
      "position": [
        656,
        224
      ],
      "id": "99c551f6-1546-44dd-abe1-1a9781a4152e",
      "name": "Azure OpenAI Chat Model",
      "credentials": {
        "azureOpenAiApi": {
          "id": "YE0Z3B80WtIEJQHi",
          "name": "Azure Open AI account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.question }}",
        "options": {
          "systemMessage": "=Je bent een AI-agent die gebruikersvragen beantwoordt uitsluitend op basis van artikelen die worden opgehaald via de tool search_articles (RD). Je mag geen informatie gebruiken uit internetbronnen, externe data of eigen kennis buiten de artikelen die door deze tools worden aangeleverd.\n\nHet is vandaag {{ $now }}\n\nBronselectie\n\nAls de gebruiker geen specifieke bron noemt, gebruik je de bron van RD.\n\nAls de gebruiker wél één specifieke bron noemt, gebruik je alleen die bron.\n\nTijdsfilters\n\nAls de gebruiker een periode of datumfilter opgeeft, gebruik je alleen artikelen waarvan publishedAt valt binnen [fromISO, toISO).\n\nGebruik van artikeldata\n\nGebruik alleen de metadatavelden uit de vectordatabases:\n\nRD: rdId, title, lead, body, publishedAt, link\n\nVerwerk de inhoud feitelijk, helder en journalistiek. Combineer en parafraseer indien nodig, maar verzín nooit informatie. Als informatie ontbreekt, zeg dat eerlijk.\n\nStructuur van het antwoord\n\nBegin direct met het inhoudelijke antwoord (maximaal 70 woorden).\n\nGebruik geen kopjes of nummering zoals “1.” of “2.”.\n\nSchrijf in helder, neutraal Nederlands met een journalistieke toon.\n\nOnder het antwoord komt altijd een bronnenlijst.\n\nBronnenlijst (verplicht)\n\nPlaats onder het antwoord altijd:\n\nBronnenlijst:\n\nAlleen de bronnen die je daadwerkelijk hebt gebruikt.\n\nDe links moeten altijd geopend kunnen worden door erop te klikken, zoals een Markdown Link.\n\nGebruik deze vaste structuur:\n\nAls RD is gebruikt:\nRD:\n[titel](link) - datum (DD-MM-YYYY)\n\nOpmaakregels\n\nGebruik in je antwoord ongeveer 50 woorden, de bronnenlijst niet meegerekend.\n\nDe links moeten altijd geopend kunnen worden door erop te klikken, zoals een Markdown Link.\n\nGeen HTML, geen extra styling, geen andere opmaak.\n\nNoem nooit bronnen die niet gebruikt zijn.\n\nToon geen irrelevante metadata (zoals ID’s).",
          "returnIntermediateSteps": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        720,
        0
      ],
      "id": "b9f73523-e668-405a-9fc4-3635724f1076",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $json.output }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        1136,
        0
      ],
      "id": "766467b1-26a7-4b9e-bc4a-5388a50ae709",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "description": "\"Als een gebruiker een vraag stelt over het RD, embed je deze en haal je de top-K dichtstbijzijnde krantenartikelen op uit Weaviate. Retourneert rang, rdId, titel en afstand.\"",
        "workflowId": {
          "__rl": true,
          "value": "XtIf9H8x2z9xAW71",
          "mode": "list",
          "cachedResultUrl": "/workflow/XtIf9H8x2z9xAW71",
          "cachedResultName": "search_articles"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ $json.question }}",
            "fromISO": "={{ $json.fromISO }}",
            "toISO": "={{ $json.toISO }}",
            "forceNewest": "={{ $json.forceNewest }}"
          },
          "matchingColumns": [
            "query"
          ],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fromISO",
              "displayName": "fromISO",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "toISO",
              "displayName": "toISO",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "forceNewest",
              "displayName": "forceNewest",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        928,
        224
      ],
      "id": "f9e6fc14-c2f2-4690-8564-fe641927dff6",
      "name": "search_articles"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Code node — Run Once for Each Item\nconst body    = $json.body    ?? {};\nconst headers = $json.headers ?? {};\nconst cookies = $json.cookies ?? {};\n\n// 1) Probeer inkomende waarden\nlet sessionId =\n  body.sessionId ||\n  headers['x-session-id'] ||\n  headers['x-sessionid'] ||\n  cookies.sid ||\n  cookies.session ||\n  null;\n\n// 2) Indien leeg: maak een stabiele fallback (hash van IP+UA+userId/dag)\nif (!sessionId) {\n  const ua = headers['user-agent'] || '';\n  const ip = (headers['x-forwarded-for'] || '').split(',')[0].trim();\n  const userId = body.userId || '';\n  const day = new Date().toISOString().slice(0,10); // optioneel: per dag uniek\n\n  const seed = `${ua}|${ip}|${userId}|${day}`;\n  function cheapHash(s){\n    let h = 0;\n    for (let i = 0; i < s.length; i++) { h = (h << 5) - h + s.charCodeAt(i); h |= 0; }\n    return `sess_${Math.abs(h)}`;\n  }\n  sessionId = cheapHash(seed);\n}\n\nreturn {\n  ...$json,\n  sessionId,        // <— dit veld gaan we gebruiken in de Memory node\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        0
      ],
      "id": "9b05b03f-7df9-416c-a8c8-bcc993332103",
      "name": "Add SessionID"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        800,
        224
      ],
      "id": "d3cc57de-1bf6-4b60-9022-8f4674a14af6",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "description": "\"Als een gebruiker een vraag stelt over het Terdege, embed je deze en haal je de top-K dichtstbijzijnde krantenartikelen op uit Weaviate. Retourneert rang, rdId, titel, body, auteur en afstand.\"",
        "workflowId": {
          "__rl": true,
          "value": "RB8P3kaD1FKCefE6",
          "mode": "list",
          "cachedResultUrl": "/workflow/RB8P3kaD1FKCefE6",
          "cachedResultName": "search_td_articles"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ $json.question }}",
            "fromISO": "={{ $json.fromISO }}",
            "toISO": "={{ $json.toISO }}",
            "forceNewest": "={{ $json.forceNewest }}",
            "authorHint": "={{ $json.authorHint }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fromISO",
              "displayName": "fromISO",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "toISO",
              "displayName": "toISO",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "forceNewest",
              "displayName": "forceNewest",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "authorHint",
              "displayName": "authorHint",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        1072,
        224
      ],
      "id": "c94b5307-3c6d-45a7-ae81-f336689c901f",
      "name": "search_td_articles",
      "disabled": true
    }
  ],
  "pinData": {},
  "connections": {
    "Chat UI webhook": {
      "main": [
        [
          {
            "node": "Validate Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Request": {
      "main": [
        [
          {
            "node": "Add SessionID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Azure OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "search_articles": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Add SessionID": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "search_td_articles": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "cfb00910-acd7-467b-9667-44f089ab4d84",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "05e2ac2e55aa48fb683263ea31b47076a892caa1c2a7fa8bbefe471edf0be5ca"
  },
  "id": "Ll2jddZ0K9LHUuEF",
  "tags": []
}