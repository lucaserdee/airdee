{
  "name": "AIRDEE",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ai-chatbot",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "a890e71c-d6db-4dbf-ae1d-49efeaca00bd",
      "name": "Chat UI webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        416,
        272
      ],
      "webhookId": "0e361650-fbdc-493a-82ea-1081b0fc552b"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate Request ‚Äî Europe/Amsterdam tijdsparser met UTC-output\n// In:  body.question (string), optioneel: body.timeRange | body.daterange | body.range\n// Out: question, fromISO, toISO, _timeRangeParsed (label), forceNewest (bool)\n\n// ========================\n// Helpers: TZ & daggrenzen\n// ========================\nconst TZ = 'Europe/Amsterdam';\nconst MS_DAY = 86_400_000;\n\nconst toIsoUtc = (d) => new Date(d.getTime()).toISOString();\n\n/**\n * Neem een (UTC) instant (of \"nu\"), projecteer naar lokale tijd in TZ,\n * zet die lokale tijd naar 00:00:00, en geef de UTC-instant terug van dat moment.\n */\nfunction startOfDayInTzUTC(d = new Date(), tz = TZ) {\n  const local = new Date(d.toLocaleString('en-US', { timeZone: tz }));\n  local.setHours(0, 0, 0, 0);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\n/** Ga n kalenderdagen vooruit/achteruit vanuit een TZ-dagstart, en geef weer de UTC-instant terug */\nfunction addDaysInTzUTC(dayStartUTC, n, tz = TZ) {\n  const local = new Date(dayStartUTC.toLocaleString('en-US', { timeZone: tz }));\n  local.setDate(local.getDate() + n);\n  local.setHours(0, 0, 0, 0);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\n/** Maandag-start van de week in TZ ‚Üí UTC instant */\nfunction startOfWeekInTzUTC(d = new Date(), tz = TZ) {\n  // Zet naar lokale 00:00 eerst\n  const local = new Date(d.toLocaleString('en-US', { timeZone: tz }));\n  local.setHours(0, 0, 0, 0);\n  // getDay(): 0=zo,1=ma,...; we willen maandag=0\n  const weekday = local.getDay(); // 0..6\n  const offset = (weekday + 6) % 7; // zo(0)->6, ma(1)->0, ...\n  local.setDate(local.getDate() - offset);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\n/** Eerste dag van de maand in TZ ‚Üí UTC instant */\nfunction startOfMonthInTzUTC(d = new Date(), tz = TZ) {\n  const local = new Date(d.toLocaleString('en-US', { timeZone: tz }));\n  local.setUTCFullYear(local.getFullYear(), local.getMonth(), 1);\n  local.setHours(0, 0, 0, 0);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\n/** Eerste dag van het jaar in TZ ‚Üí UTC instant */\nfunction startOfYearInTzUTC(d = new Date(), tz = TZ) {\n  const local = new Date(d.toLocaleString('en-US', { timeZone: tz }));\n  local.setUTCFullYear(local.getFullYear(), 0, 1);\n  local.setHours(0, 0, 0, 0);\n  return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n}\n\n// ========================\n// Datums (NL) parsen\n// ========================\n/** @type {{ [k: string]: number }} */\nconst MONTHS = {\n  januari: 0, februari: 1, maart: 2, april: 3, mei: 4, juni: 5,\n  juli: 6, augustus: 7, september: 8, oktober: 9, november: 10, december: 11,\n};\n\n/**\n * Parse \"dd-mm(-yyyy)\" | \"dd/mm(/yyyy)\" | \"dd <maand> (yyyy)\" | ISO\n * Retourneer UTC instant van 00:00 lokale dag in TZ, of null.\n */\nfunction parseLooseDateToTzStartUTC(s, defaultYear, tz = TZ) {\n  if (!s) return null;\n  s = String(s).trim().toLowerCase();\n\n  // dd-mm(-yyyy) | dd/mm(/yyyy) | dd.mm(.yyyy)\n  let m = s.match(/^(\\d{1,2})[.\\-\\/ ](\\d{1,2})(?:[.\\-\\/ ](\\d{2,4}))?$/);\n  if (m) {\n    const d = +m[1], mo = +m[2], y = m[3] ? +m[3] : defaultYear;\n    const yyyy = y < 100 ? 2000 + y : y;\n    const local = new Date(new Date().toLocaleString('en-US', { timeZone: tz }));\n    local.setFullYear(yyyy, mo - 1, d);\n    local.setHours(0, 0, 0, 0);\n    return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n  }\n\n  // dd <maand> (yyyy)\n  m = s.match(/^(\\d{1,2})[ ]([a-z]+)\\.?(?:[ ](\\d{2,4}))?$/i);\n  if (m) {\n    const d = +m[1];\n    const monName = m[2].replace(/\\.$/, '');\n    const mo = MONTHS[monName];\n    if (mo !== undefined) {\n      const y = m[3] ? +m[3] : defaultYear;\n      const yyyy = y < 100 ? 2000 + y : y;\n      const local = new Date(new Date().toLocaleString('en-US', { timeZone: tz }));\n      local.setFullYear(yyyy, mo, d);\n      local.setHours(0, 0, 0, 0);\n      return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n    }\n  }\n\n  // ISO fallback (neem kalenderdag in TZ)\n  const iso = new Date(s);\n  if (!isNaN(iso.getTime())) {\n    const local = new Date(iso.toLocaleString('en-US', { timeZone: tz }));\n    local.setHours(0, 0, 0, 0);\n    return new Date(local.toLocaleString('en-US', { timeZone: 'UTC' }));\n  }\n\n  return null;\n}\n\n// ========================\n// Tijdsrange parser (NL)\n// ========================\nfunction parseTimeRangeNL(input, questionText) {\n  const src = (input || questionText || '').trim();\n  if (!src) return { fromISO: null, toISO: null, label: null };\n\n  const s = src.toLowerCase();\n  const now = new Date();\n  const todayUTC = startOfDayInTzUTC(now);\n  const tomorrowUTC = addDaysInTzUTC(todayUTC, 1);\n\n  // Snelle presets: vandaag/gisteren/eergisteren\n  if (/\\b(vandaag)\\b/.test(s)) {\n    return { fromISO: toIsoUtc(todayUTC), toISO: toIsoUtc(tomorrowUTC), label: 'vandaag' };\n  }\n  if (/\\b(gisteren)\\b/.test(s)) {\n    const yUTC = addDaysInTzUTC(todayUTC, -1);\n    return { fromISO: toIsoUtc(yUTC), toISO: toIsoUtc(todayUTC), label: 'gisteren' };\n  }\n  if (/\\b(eergisteren)\\b/.test(s)) {\n    const d2UTC = addDaysInTzUTC(todayUTC, -2);\n    const d1UTC = addDaysInTzUTC(todayUTC, -1);\n    return { fromISO: toIsoUtc(d2UTC), toISO: toIsoUtc(d1UTC), label: 'eergisteren' };\n  }\n\n  // \"afgelopen twee weken\"\n  if (/(afgelopen|laatste)\\s*(twee|2)\\s*weken?\\b/.test(s)) {\n    const from = addDaysInTzUTC(todayUTC, -14);\n    return { fromISO: toIsoUtc(from), toISO: toIsoUtc(tomorrowUTC), label: 'afgelopen twee weken' };\n  }\n\n  // \"afgelopen N dagen/weken/maanden/jaar\"\n  let m = s.match(/(afgelopen|laatste)\\s*(\\d{1,3})\\s*(dagen?|weken?|maanden?|jaar)\\b/);\n  if (m) {\n    const n = +m[2];\n    const unit = m[3];\n    let fromUTC = todayUTC;\n\n    if (/dag/.test(unit)) {\n      fromUTC = addDaysInTzUTC(todayUTC, -n);\n    } else if (/week/.test(unit)) {\n      fromUTC = addDaysInTzUTC(todayUTC, -7 * n);\n    } else if (/maand/.test(unit)) {\n      // n maanden terug ‚Üí eerste dag van die maand\n      const localNow = new Date(now.toLocaleString('en-US', { timeZone: TZ }));\n      localNow.setMonth(localNow.getMonth() - n, 1);\n      localNow.setHours(0, 0, 0, 0);\n      fromUTC = new Date(localNow.toLocaleString('en-US', { timeZone: 'UTC' }));\n    } else if (/jaar/.test(unit)) {\n      const localNow = new Date(now.toLocaleString('en-US', { timeZone: TZ }));\n      localNow.setFullYear(localNow.getFullYear() - n, 0, 1);\n      localNow.setHours(0, 0, 0, 0);\n      fromUTC = new Date(localNow.toLocaleString('en-US', { timeZone: 'UTC' }));\n    }\n\n    return { fromISO: toIsoUtc(fromUTC), toISO: toIsoUtc(tomorrowUTC), label: `afgelopen ${n} ${unit}` };\n  }\n\n  // \"vorige week\" (ma-zo v√≥√≥r deze week)\n  if (/\\b(vorige|afgelopen)\\s+week\\b/.test(s)) {\n    const startThisWeekUTC = startOfWeekInTzUTC(now);\n    const startPrevWeekUTC = addDaysInTzUTC(startThisWeekUTC, -7);\n    return { fromISO: toIsoUtc(startPrevWeekUTC), toISO: toIsoUtc(startThisWeekUTC), label: 'vorige week' };\n  }\n\n  // \"deze week\" (maandag 00:00 t/m nu+1dag 00:00)\n  if (/\\bdeze\\s+week\\b/.test(s)) {\n    const startThisWeekUTC = startOfWeekInTzUTC(now);\n    return { fromISO: toIsoUtc(startThisWeekUTC), toISO: toIsoUtc(tomorrowUTC), label: 'deze week' };\n  }\n\n  // \"vorige maand\"\n  if (/\\b(vorige|afgelopen)\\s+maand\\b/.test(s)) {\n    const firstThisUTC = startOfMonthInTzUTC(now);\n    const localThis = new Date(firstThisUTC.toLocaleString('en-US', { timeZone: TZ }));\n    localThis.setMonth(localThis.getMonth() - 1, 1);\n    localThis.setHours(0, 0, 0, 0);\n    const firstPrevUTC = new Date(localThis.toLocaleString('en-US', { timeZone: 'UTC' }));\n    return { fromISO: toIsoUtc(firstPrevUTC), toISO: toIsoUtc(firstThisUTC), label: 'vorige maand' };\n  }\n\n  // \"deze maand\"\n  if (/\\bdeze\\s+maand\\b/.test(s)) {\n    const firstThisUTC = startOfMonthInTzUTC(now);\n    return { fromISO: toIsoUtc(firstThisUTC), toISO: toIsoUtc(tomorrowUTC), label: 'deze maand' };\n  }\n\n  // \"vorig jaar\"\n  if (/\\b(vorig|afgelopen)\\s+jaar\\b/.test(s)) {\n    const firstThisYearUTC = startOfYearInTzUTC(now);\n    const localThis = new Date(firstThisYearUTC.toLocaleString('en-US', { timeZone: TZ }));\n    localThis.setFullYear(localThis.getFullYear() - 1, 0, 1);\n    localThis.setHours(0, 0, 0, 0);\n    const firstPrevYearUTC = new Date(localThis.toLocaleString('en-US', { timeZone: 'UTC' }));\n    return { fromISO: toIsoUtc(firstPrevYearUTC), toISO: toIsoUtc(firstThisYearUTC), label: 'vorig jaar' };\n  }\n\n  // \"dit jaar\"\n  if (/\\bdit\\s+jaar\\b/.test(s)) {\n    const firstThisYearUTC = startOfYearInTzUTC(now);\n    return { fromISO: toIsoUtc(firstThisYearUTC), toISO: toIsoUtc(addDaysInTzUTC(todayUTC, 1)), label: 'dit jaar' };\n  }\n\n  // \"A t/m B\" (inclusief B, dus tot B+1 dag 00:00)\n  m = s.match(/(.+?)\\s*t\\/m\\s*(.+)$/i);\n  if (m) {\n    const a = parseLooseDateToTzStartUTC(m[1], now.getFullYear(), TZ);\n    const b = parseLooseDateToTzStartUTC(m[2], now.getFullYear(), TZ);\n    if (a && b) return { fromISO: toIsoUtc(a), toISO: toIsoUtc(addDaysInTzUTC(b, 1)), label: 'custom range' };\n  }\n\n  // \"tussen A en B\" (inclusief B ‚Üí tot B+1)\n  m = s.match(/tussen\\s+(.+?)\\s+en\\s+(.+)$/i);\n  if (m) {\n    const a = parseLooseDateToTzStartUTC(m[1], now.getFullYear(), TZ);\n    const b = parseLooseDateToTzStartUTC(m[2], now.getFullYear(), TZ);\n    if (a && b) return { fromISO: toIsoUtc(a), toISO: toIsoUtc(addDaysInTzUTC(b, 1)), label: 'custom range' };\n  }\n\n  // \"op <datum>\"\n  m = s.match(/\\bop\\s+(.+)$/i);\n  if (m) {\n    const d0 = parseLooseDateToTzStartUTC(m[1], now.getFullYear(), TZ);\n    if (d0) return { fromISO: toIsoUtc(d0), toISO: toIsoUtc(addDaysInTzUTC(d0, 1)), label: 'op dag' };\n  }\n\n  // Geen match\n  return { fromISO: null, toISO: null, label: null };\n}\n\n// ========================\n// Node-uitvoering\n// ========================\nconst body = $json.body ?? {};\nconst question = String(body.question ?? '').trim();\nif (!question) {\n  throw new Error('question ontbreekt in de request payload.');\n}\n\n// 1) Tijdsvenster ophalen (expliciet of uit de vraag)\nconst explicitTR = body.timeRange ?? body.daterange ?? body.range ?? null;\nlet parsed = parseTimeRangeNL(explicitTR, question);\nconst { fromISO, toISO, label } = parsed;\n\n// 2) Intentie ‚Äúnieuwste/laatste/recentste‚Äù ‚Üí forceNewest\nconst qLower = question.toLowerCase();\nconst forceNewest = /\\b(nieuwste|laatste|recentste)\\b/.test(qLower);\n\n// 3) Output naar volgende nodes\nreturn {\n  question,\n  fromISO,\n  toISO,\n  _timeRangeParsed: label,\n  forceNewest\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        640,
        272
      ],
      "id": "3a92920a-97ac-4332-9ffe-6b162b681f91",
      "name": "Validate Request"
    },
    {
      "parameters": {
        "model": "gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAzureOpenAi",
      "typeVersion": 1,
      "position": [
        1088,
        496
      ],
      "id": "ff241851-8635-4c46-bfba-09dbaec51efb",
      "name": "Azure OpenAI Chat Model",
      "credentials": {
        "azureOpenAiApi": {
          "id": "r53g3Mv4leJjmPvW",
          "name": "Azure Open AI account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.question }}",
        "options": {
          "systemMessage": "=üîπ Rol en doel\n\nJe bent AIRDEE, de AI-assistent van Erdee Media Groep (EMG).\nJe helpt lezers en redacteuren door vragen te beantwoorden op basis van artikelen uit de EMG-database.\nJe kennis komt uitsluitend uit die artikelen ‚Äî niet uit andere bronnen of het web.\nVandaag is het {{ $now }}\n\n\nüîπ Gebruik van de tool search_articles\n\nJe gebruikt altijd de tool search_articles om relevante artikelen op te halen.\nJe mag geen antwoord geven zonder eerst deze tool te gebruiken.\n\nParameters van search_articles:\nNaam\tBeschrijving\nquery\tDe originele gebruikersvraag (bijv. ‚ÄúWat schreef RD over onderwijs deze week?‚Äù)\nfromISO\tStartdatum van het venster (optioneel, ISO 8601 UTC)\ntoISO\tEinddatum van het venster (optioneel, ISO 8601 UTC)\nforceNewest\ttrue als de gebruiker vraagt naar ‚Äúnieuwste‚Äù, ‚Äúlaatste‚Äù of ‚Äúrecentste‚Äù artikelen\nResultaat:\n\nDe tool retourneert een lijst results[] met o.a.:\n\ntitle, lead, body,\n\npublishedAt, rdId,\n\nlink of url,\n\nen eventueel in_range, distance, strict_range.\n\nüîπ Werkwijze\n\nGebruik altijd de tool search_articles.\nRoep deze tool aan zodra je een gebruikersvraag ontvangt.\n\nLees de resultaten (results[]) en gebruik uitsluitend die artikelen om te antwoorden.\nNegeer alle andere kennis of achtergrondinformatie.\n\nCombineer waar relevant meerdere artikelen en vermeld per artikel:\n\nde titel,\n\nde publicatiedatum (formaat: dd-mm-yyyy),\n\nen een klikbare bronlink in Markdown ([titel](link)).\n\nWanneer een tijdsfilter is toegepast (fromISO of toISO):\n\ngebruik alleen artikelen waarvan publishedAt binnen [fromISO, toISO) ligt.\n\nVoeg onderaan een machineleesbaar JSON-blok toe:\n\nTIME_FILTER_JSON: {\n  \"from\": \"2025-10-14T00:00:00Z\",\n  \"to\": \"2025-10-21T23:59:59Z\",\n  \"field\": \"publishedAt\",\n  \"label\": \"Afgelopen week t/m vandaag\"\n}\n\n\nAls er geen artikelen in de gevraagde periode zijn:\n\nmeld dat feitelijk, bijvoorbeeld:\n‚ÄúEr zijn geen artikelen gevonden binnen de opgegeven periode.‚Äù\n\nüîπ Stijl en toon\n\nSchrijf in vloeiend, helder Nederlands, passend bij de journalistieke stijl van Reformatorisch Dagblad / EMG.\n\nWees feitelijk, rustig en objectief.\n\nVermijd overdrijving, opinie of speculatie.\n\nGebruik geen emoji‚Äôs, HTML of overbodige opsmuk.\n\nGebruik Markdown-links voor bronnen.\n\nüîπ Samenvatting van je gedrag\n\nBegrijp de intentie en (indien aanwezig) de tijdsperiode van de vraag.\n\nGebruik altijd de tool search_articles ‚Äî zonder uitzondering.\n\nBeantwoord de vraag uitsluitend met gegevens uit die artikelen.\n\nVermeld bronnen en publicatiedata.\n\nVoeg het tijdsfilter-JSON toe als het relevant is.\n\nHoud een neutrale, betrouwbare toon die past bij Erdee Media Groep.",
          "returnIntermediateSteps": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1136,
        272
      ],
      "id": "750febc4-542e-4d7f-99d8-738864a49ea4",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $json.output }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        1552,
        272
      ],
      "id": "cab56960-5bc3-432d-88ca-06f62f84f998",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "description": "\"Als een gebruiker een vraag stelt, embed je deze en haal je de top-K dichtstbijzijnde krantenartikelen op uit Weaviate. Retourneert rang, rdId, titel en afstand.\"",
        "workflowId": {
          "__rl": true,
          "value": "13IhSMkzb9YUf0PP",
          "mode": "list",
          "cachedResultUrl": "/workflow/13IhSMkzb9YUf0PP",
          "cachedResultName": "search_articles"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ $json.question }}",
            "fromISO": "={{ $json.fromISO }}",
            "toISO": "={{ $json.toISO }}",
            "forceNewest": "={{ $json.forceNewest }}"
          },
          "matchingColumns": [
            "query"
          ],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "fromISO",
              "displayName": "fromISO",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "toISO",
              "displayName": "toISO",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "forceNewest",
              "displayName": "forceNewest",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        1344,
        496
      ],
      "id": "8efcd1ca-d5dc-4861-85fd-1ec60c821d67",
      "name": "search_articles"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Code node ‚Äî Run Once for Each Item\nconst body    = $json.body    ?? {};\nconst headers = $json.headers ?? {};\nconst cookies = $json.cookies ?? {};\n\n// 1) Probeer inkomende waarden\nlet sessionId =\n  body.sessionId ||\n  headers['x-session-id'] ||\n  headers['x-sessionid'] ||\n  cookies.sid ||\n  cookies.session ||\n  null;\n\n// 2) Indien leeg: maak een stabiele fallback (hash van IP+UA+userId/dag)\nif (!sessionId) {\n  const ua = headers['user-agent'] || '';\n  const ip = (headers['x-forwarded-for'] || '').split(',')[0].trim();\n  const userId = body.userId || '';\n  const day = new Date().toISOString().slice(0,10); // optioneel: per dag uniek\n\n  const seed = `${ua}|${ip}|${userId}|${day}`;\n  function cheapHash(s){\n    let h = 0;\n    for (let i = 0; i < s.length; i++) { h = (h << 5) - h + s.charCodeAt(i); h |= 0; }\n    return `sess_${Math.abs(h)}`;\n  }\n  sessionId = cheapHash(seed);\n}\n\nreturn {\n  ...$json,\n  sessionId,        // <‚Äî dit veld gaan we gebruiken in de Memory node\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        272
      ],
      "id": "e3b8e1b4-c3a1-4bd3-aca3-179465e57334",
      "name": "Add SessionID"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        1216,
        496
      ],
      "id": "3058947c-af11-4d9f-8614-afb0cd5eae8d",
      "name": "Simple Memory"
    }
  ],
  "pinData": {},
  "connections": {
    "Chat UI webhook": {
      "main": [
        [
          {
            "node": "Validate Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Request": {
      "main": [
        [
          {
            "node": "Add SessionID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Azure OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "search_articles": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Add SessionID": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "ee5bb27a-c8d4-4e3b-beef-35be2380870a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "3d6c34d8f4384ca25fa01e0f923a6457166bf650c040640922e8f719be8d8641"
  },
  "id": "ouh1AgfENaD3z84P",
  "tags": []
}